# Legacy Reference Strategy（Legacy 參考資料使用策略）

## 狀態
- ACTIVE
- EDITABLE
- 建立日期：2026-01-09

---

## 目的
明確定義何時、如何向副指揮官和顧問師提供 legacy 參考資料，平衡「避免重複錯誤」與「不限制創新思維」兩個目標。

---

## 核心原則

### 1. 分層參考策略（Layered Reference Strategy）
- **第一輪（初始設計）**：提供「失敗模式摘要」和「硬性約束」，不提供完整 legacy 代碼
- **第二輪（優化改進）**：提供「可回收零件」和「具體案例」，用於優化和擴充
- **第三輪（深度優化）**：提供完整 legacy 分析，用於深度優化和架構調整

### 2. 避免污染原則（Avoid Contamination Principle）
- **禁止**：在第一輪提供完整 legacy 代碼或詳細實作細節
- **允許**：在第一輪提供「已知失敗模式」和「必須避免的錯誤」
- **目標**：讓顧問師知道「不能做什麼」，但不限制「可以做什麼」

---

## 第一輪（初始設計）策略

### 必須提供的內容（基於歷史失敗教訓）

#### 1. 核心失敗模式警告（Critical Failure Pattern Warnings）
**基於歷史失敗案例，必須在第一輪任務包中明確警告：**

##### 失敗模式 A：不使用文本記錄（對話內版本漂移）
- **歷史案例**：第一次失敗 - GPT 一直寫一直寫，最後一個人就寫出四個版本的題目
- **失敗原因**：沒有使用文本記錄，導致版本漂移、引用路徑互相衝突
- **關鍵教訓**：
  - 即使第四版題目確實比較好，但因為沒有文本記錄，最後因整包重做而汰除
  - **所有決策和產出都必須立即寫入文本，不得只存在對話中**
- **必須避免**：
  - ❌ 在對話中反覆修改而不寫入文本
  - ❌ 讓 AI 自行產生多個版本而不記錄決策過程
  - ❌ 依賴對話記憶而非文本記錄
- **必須執行**：
  - ✅ 所有顧問輸出必須立即寫入 `docs/gem/runs/`
  - ✅ 所有決策必須立即寫入對應的 domain 文件或 ADR
  - ✅ 版本變更必須有明確的 manifest 和 schema 版本化
  - ✅ 引用路徑必須可由 manifest/compile 推導且能測試

##### 失敗模式 B：把決定權責都交給 AI（規則寫死導致卡死）
- **歷史案例**：第二次失敗 - AI 一開始把最高規範定死了，而且訂出沒辦法滿足終極目標的規範
- **失敗原因**：把決定的權責都交給 AI，導致後期沒有辦法修復
- **關鍵教訓**：
  - 不是因為題目內容等等東西寫得太爛，而是因為規則寫死導致無法調整
  - **使用者必須保留最終決策權，AI 不得自行訂死不可變的規則**
- **必須避免**：
  - ❌ AI 自行訂定「不可變」的規則
  - ❌ 規則與終極目標（NORTH_STAR）不一致
  - ❌ 缺少「合法變更機制」（可回滾、可覆蓋的改規則路徑）
- **必須執行**：
  - ✅ 使用者擁有最高主權（CHARTER）+ 可回滾（checkpoint）= 永遠可改
  - ✅ 規則/架構變更走 ADR + 使用者批准（不是不能改，是要能審計地改）
  - ✅ 若發現規則不再服務目標：允許「新 checkpoint 覆蓋進度」而非硬扛
  - ✅ 所有規則都能用「新增 ADR + checkpoint」合法修正，不會卡死

#### 2. 失敗模式摘要（Failure Patterns Summary）
- 來源：`docs/legacy/115_1_3_my-first-app_failed/extract/FAILURE_PATTERNS.md`
- 內容：已知高風險模式（例如：版本漂移、規則卡死、整包保存但不可調用）
- 目的：讓顧問師知道「必須避免的錯誤」

#### 3. 硬性約束（Hard Constraints）
- 來源：治理規則、ADR、CHARTER、NORTH_STAR
- 內容：不可違反的規則（例如：不得暴露心理學、必須純玄學體驗）
- **特別強調**：所有規則必須服務於終極目標（NORTH_STAR），若發現不一致，必須立即提出並修正
- 目的：明確邊界條件

#### 4. 路由指針（Router Pointer）
- 來源：`docs/legacy/115_1_3_my-first-app_failed/extract/ROUTER.md`
- 內容：僅提供「路由導航」，不提供完整內容
- 目的：讓顧問師知道「如果需要參考，可以去哪裡找」

### 禁止提供的內容
- ❌ 完整 legacy 代碼
- ❌ 詳細實作細節
- ❌ 過去的設計方案（除非是明確的「反例」）
- ❌ 過去的決策過程（除非是明確的「失敗案例」）

### 提供方式
- **任務包格式**：在任務包的「禁區」或「必須避免的錯誤」章節中提供
- **標註方式**：明確標註為 `[LEGACY_FAILED]` 參考，並說明「僅作反例，不作為設計依據」

---

## 第二輪（優化改進）策略

### 可以提供的內容
1. **可回收零件**（Reusable Assets）
   - 來源：`docs/legacy/115_1_3_my-first-app_failed/extract/REUSABLE_ASSETS.md`
   - 內容：過去版本中可以回收使用的零件（需經裁決）
   - 目的：優化現有設計，避免重複造輪子

2. **具體案例**（Specific Cases）
   - 來源：legacy 中的具體實作案例
   - 內容：過去版本中的具體實作方式（作為參考，不作為標準）
   - 目的：提供優化方向

3. **能力映射**（Capability Map）
   - 來源：`docs/legacy/115_1_3_my-first-app_failed/extract/CAPABILITY_MAP.md`
   - 內容：過去版本的能力範圍和限制
   - 目的：了解過去的能力邊界，避免過度設計

### 提供方式
- **任務包格式**：在任務包的「優化參考」或「可回收零件」章節中提供
- **標註方式**：明確標註為 `[LEGACY_FAILED]` 參考，並說明「需經裁決才可復用」

---

## 第三輪（深度優化）策略

### 可以提供的內容
1. **完整 Legacy 分析**（Full Legacy Analysis）
   - 來源：legacy 的完整結構和實作
   - 內容：過去版本的完整架構、實作細節、決策過程
   - 目的：深度優化和架構調整

2. **歷史決策過程**（Historical Decision Process）
   - 來源：legacy 中的決策記錄
   - 內容：過去版本的決策過程和失敗原因
   - 目的：避免重複過去的決策錯誤

### 提供方式
- **任務包格式**：在任務包的「深度分析」或「架構調整」章節中提供
- **標註方式**：明確標註為 `[LEGACY_FAILED]` 參考，並說明「僅作深度分析，不作為直接依據」

---

## 專業設計流程對照

### 標準設計流程（Standard Design Process）
1. **第一階段（Discovery）**：了解問題、定義約束、避免已知錯誤
2. **第二階段（Design）**：自由創新、探索方案、不受過去限制
3. **第三階段（Refinement）**：基於第一階段結果，參考歷史經驗進行優化
4. **第四階段（Optimization）**：深度優化、架構調整、參考完整歷史

### 我們的策略對照
- **第一輪 = Discovery + Design**：提供失敗模式摘要和硬性約束，不限制創新
- **第二輪 = Refinement**：提供可回收零件和具體案例，用於優化
- **第三輪 = Optimization**：提供完整 legacy 分析，用於深度優化

---

## 實作建議

### 任務包格式範例

#### 第一輪任務包（初始設計）
```markdown
## 必須避免的錯誤（基於歷史失敗教訓）

### ⚠️ 核心失敗模式警告（必須遵守）

#### 失敗模式 A：不使用文本記錄（對話內版本漂移）
**歷史案例**：第一次失敗 - GPT 一直寫一直寫，最後一個人就寫出四個版本的題目

**失敗原因**：
- 沒有使用文本記錄，導致版本漂移、引用路徑互相衝突
- 即使第四版題目確實比較好，但因為沒有文本記錄，最後因整包重做而汰除

**必須避免**：
- ❌ 在對話中反覆修改而不寫入文本
- ❌ 讓 AI 自行產生多個版本而不記錄決策過程
- ❌ 依賴對話記憶而非文本記錄

**必須執行**：
- ✅ 所有顧問輸出必須立即寫入 `docs/gem/runs/`
- ✅ 所有決策必須立即寫入對應的 domain 文件或 ADR
- ✅ 版本變更必須有明確的 manifest 和 schema 版本化
- ✅ 引用路徑必須可由 manifest/compile 推導且能測試

**參考**：`docs/governance/LESSONS_LEARNED.md` - 失敗案例 A

---

#### 失敗模式 B：把決定權責都交給 AI（規則寫死導致卡死）
**歷史案例**：第二次失敗 - AI 一開始把最高規範定死了，而且訂出沒辦法滿足終極目標的規範

**失敗原因**：
- 把決定的權責都交給 AI，導致後期沒有辦法修復
- 不是因為題目內容等等東西寫得太爛，而是因為規則寫死導致無法調整

**必須避免**：
- ❌ AI 自行訂定「不可變」的規則
- ❌ 規則與終極目標（NORTH_STAR）不一致
- ❌ 缺少「合法變更機制」（可回滾、可覆蓋的改規則路徑）

**必須執行**：
- ✅ 使用者擁有最高主權（CHARTER）+ 可回滾（checkpoint）= 永遠可改
- ✅ 規則/架構變更走 ADR + 使用者批准（不是不能改，是要能審計地改）
- ✅ 若發現規則不再服務目標：允許「新 checkpoint 覆蓋進度」而非硬扛
- ✅ 所有規則都能用「新增 ADR + checkpoint」合法修正，不會卡死

**參考**：`docs/governance/LESSONS_LEARNED.md` - 失敗案例 B

---

### 已知高風險模式（技術層面）
1. **版本漂移**：同概念在多處 duplicated；引用路徑交叉
   - 對策：domain 外置化 + schema 版本化 + golden tests
   - 參考：`docs/legacy/115_1_3_my-first-app_failed/extract/FAILURE_PATTERNS.md`

2. **規則卡死**：治理/規則不可變；但需求演進必然改動
   - 對策：USER_OVERRIDE_PROTOCOL + checkpoint rollback
   - 參考：同上

### 硬性約束
- 不得暴露心理學（見 ADR_0002）
- 必須純玄學體驗（見 CHARTER）
- 必須可審計（見 ADR_0001）
- **所有規則必須服務於終極目標（NORTH_STAR），若發現不一致，必須立即提出並修正**

### Legacy 路由（如需參考）
- 路由導航：`docs/legacy/115_1_3_my-first-app_failed/extract/ROUTER.md`
- 注意：僅作導航，不提供完整內容
```

#### 第二輪任務包（優化改進）
```markdown
## 優化參考（基於 Legacy 可回收零件）

### 可回收零件
1. **UI 流程參考**：`docs/legacy/115_1_3_my-first-app_failed/extract/UI_FLOW_REFERENCES.md`
   - 說明：過去版本的 UI 流程設計（作為參考，不作為標準）
   - 用途：優化現有 UI 流程

2. **能力映射**：`docs/legacy/115_1_3_my-first-app_failed/extract/CAPABILITY_MAP.md`
   - 說明：過去版本的能力範圍和限制
   - 用途：了解過去的能力邊界，避免過度設計

### 注意事項
- 所有 legacy 參考需經裁決才可復用
- 不得直接複製 legacy 代碼或設計
```

---

## 風險與緩解

### 風險 1：第一輪提供過多 legacy 內容，限制創新思維
**緩解**：
- 只提供「失敗模式摘要」和「硬性約束」
- 不提供完整 legacy 代碼或詳細實作細節
- 明確標註「僅作反例，不作為設計依據」

### 風險 2：第一輪不提供任何 legacy 內容，重複犯同樣錯誤
**緩解**：
- 必須提供「失敗模式摘要」和「硬性約束」
- 讓顧問師知道「不能做什麼」，但不限制「可以做什麼」

### 風險 3：第二輪、第三輪才提供 legacy 內容，浪費時間和資源
**緩解**：
- 第一輪提供「路由指針」，讓顧問師知道「如果需要參考，可以去哪裡找」
- 第二輪、第三輪提供「可回收零件」和「具體案例」，用於優化

---

## 與現有規則的關係

### RESEARCH_LEGACY_SEPARATION_RULE.md
- **LEGACY_FAILED**：過往失敗版本，作為反例/零件庫
- **禁止**：把 legacy 內容當成現行設計依據直接落盤到 domain
- **本策略**：明確定義何時、如何提供 legacy 參考，避免違反此規則

### ROUTER.md
- **必須參考（consult）**：可用材料
- **不要求引用原文（quote/copy）**：不需要完整引用
- **本策略**：第一輪僅提供路由指針，第二輪、第三輪才提供具體內容

### FAILURE_PATTERNS.md
- **目的**：把「失敗」變成可查的規則與預警，不再靠記憶
- **本策略**：第一輪必須提供失敗模式摘要，避免重複犯同樣錯誤

---

## 狀態
- ACTIVE
- EDITABLE
- 必須納入任務包生成流程

